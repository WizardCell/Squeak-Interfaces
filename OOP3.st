Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'getting' stamp: 'MM 3/9/2024 04:47'!behavesLike		| inclusiveBehavesLike behavesLikeRecursive |		inclusiveBehavesLike := Set new.	behavesLikeRecursive :=	[ :behavesLikeToAdd |				(behavesLikeToAdd isEmpty or: [ inclusiveBehavesLike includesAllOf: behavesLikeToAdd. ])		ifFalse:		[			| toAddToBehavesLike |						toAddToBehavesLike := Set new.			behavesLikeToAdd do:			[				:interface |								toAddToBehavesLike add: interface.			].				inclusiveBehavesLike addAll: toAddToBehavesLike.			behavesLikeRecursive value: (MyObject directBehavesLikeOf: toAddToBehavesLike).		].	].	behavesLikeRecursive value: behavesLike.		self allSuperclassesDo:	[		:superclass |				(superclass == MyObject or: [superclass == Object.] or: [ superclass == ProtoObject ])		ifFalse:		[			behavesLikeRecursive value: superclass behavesLike.		].	].		"Interfaces always behave like themselves"	(isInterface)	ifTrue:	[		inclusiveBehavesLike add: self.	].	^inclusiveBehavesLike.! !!MyObject class methodsFor: 'getting' stamp: 'MM 3/7/2024 00:52'!isInterface	^isInterface.! !!MyObject class methodsFor: 'issues' stamp: 'MM 3/9/2024 13:28'!ambiguities	| ambiguitiesMap allAmbiguities |		ambiguitiesMap := Dictionary new.		self behavesLike do:	[		:interface |		interface methodsDo:		[			:method |			(ambiguitiesMap includesKey: (method selector))			ifFalse:			[				"false indicates method has no ambiguity, and since this is the first time we see the method, it's not ambigious indeed"				ambiguitiesMap at: (method selector) put: false.			]			ifTrue:			[				"true indicates method has an ambiguity, and since we've seen it before, it's ambigious indeed"				ambiguitiesMap at: (method selector) put: true.			]		].	].	allAmbiguities := SortedCollection new.	ambiguitiesMap keysAndValuesDo:	[		:selector :isAmbiguity |				(isAmbiguity)		ifTrue:		[			allAmbiguities add: selector.		].	].	^allAmbiguities.		! !!MyObject class methodsFor: 'utility' stamp: 'MM 3/9/2024 04:49'!directBehavesLikeOf: aInterfaceCollection	"Returns the interfaces, aInterfaceCollection behaves like directly"	| aSet |		aSet := Set new.		aInterfaceCollection do:	[		:interface |				aSet addAll: interface behavesLike.	].	^aSet.! !!MyObject class methodsFor: 'utility' stamp: 'MM 3/9/2024 06:55'!methodHasBody: aCodeString	"Given a string of code for a method, check if it has a body/implementation"	| methodBodyStartIndex |		"Find the last occurrence of '|' character in the original source code"	methodBodyStartIndex := aCodeString lastIndexOf: $|.		"Check if '|' character is found, indicating we have temporary variables"	(methodBodyStartIndex = 0)	ifTrue:	[		"Method has no temprary variables"		| lines |		"Split the original method body into lines"		lines := aCodeString lines.		(lines size >= 2)		ifTrue: [ ^true. ]		ifFalse: [ ^false. ].	]	ifFalse:	[    		"Method has temprary variables"		| lines |		"Split the original method body into lines"		lines := aCodeString lines.		(lines size >= 3)		ifTrue: [ ^true. ]		ifFalse: [ ^false. ].	].! !!MyObject class methodsFor: 'utility' stamp: 'MM 3/9/2024 13:57'!subclass: aSubclass implements: anInterface	"Whether a subclass implements an interface"					anInterface behavesLike do:	[		:linkedInterface |							linkedInterface methodsDo:		[			:method |									(aSubclass canUnderstand: method selector)			ifFalse:			[				"Transcript show: aSubclass name; show: ' has no implementation for method '; show: method selector; cr."				"We reached the inheritance tree peek, so there is no way we will find an implementation for this subclass, but we might find for others if we are still traversing"						^false.			]		].	].	^true.! !!MyObject class methodsFor: 'testing' stamp: 'MM 3/10/2024 03:04'!isImplemented	| interfaceKnowsNoMethods |		(isInterface)	ifFalse: [ AssertionFailure signal: (self name, ' is not an interface!!'). ].		interfaceKnowsNoMethods := true.	"Special case: an interface that knows no methods is implemented if a class/interface that behaves like the former exists"			self behavesLike do:	[		:interface |				(interface hasMethods)		ifTrue:		[			interfaceKnowsNoMethods := false.		]	].	(interfaceKnowsNoMethods)	ifTrue:	[		MyObject allSubclassesDo:		[			:subclass |					(subclass behavesLike includes: self)			ifTrue:			[				^true.			].		].	].		MyObject allSubclassesDo:	[		:subclass |				(subclass isInterface)		ifFalse:		[			(subclass behavesLike includes: self)			ifTrue:			[				(self subclass: subclass implements: self)				ifTrue: [ ^true. ].			].		].	].	^false.! !!MyObject class methodsFor: 'instance creation' stamp: 'MM 3/8/2024 03:36'!new	(self isInterface)	ifTrue: [ AssertionFailure signal: ('Interfaces can not be instantiated!!'). ]	ifFalse: [ ^super new. ].! !!MyObject class methodsFor: 'instance creation' stamp: 'MM 3/8/2024 01:54'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	| instantiatedClass |		(self isInterface)	ifTrue: [ AssertionFailure signal: ('Classes can not derive from an interface!!'). ].		instantiatedClass := (ClassBuilder new)						superclass: self						subclass: aSubclassName						instanceVariableNames: instVarNames						classVariableNames: classVarNames						poolDictionaries: poolDictionaries						category: aCategoryName.		instantiatedClass instVarNamed: 'isInterface' put: false.	instantiatedClass instVarNamed: 'behavesLike' put: (superclass behavesLike copy).	^instantiatedClass.! !!MyObject class methodsFor: 'instance creation' stamp: 'MM 3/8/2024 01:52'!subclass: aSubclassName isInterface: isInterface behavesLike: caCollectioninstanceVariableNames: instVarNames classVariableNames: classVarNamespoolDictionaries: poolDictionaries category: aCategoryName	| instantiatedClass |
	(isInterface)	ifTrue:	[		(self == MyObject)		ifFalse: [ AssertionFailure signal: ('Interfaces must derive from MyObject!!'). ].				((instVarNames isEmpty) and: [ (classVarNames isEmpty) ])		ifFalse: [ AssertionFailure signal: ('Interfaces can not have state!!'). ].	]	ifFalse:	[		(self isInterface)		ifTrue: [ AssertionFailure signal: ('Classes can not derive from an interface!!'). ]	].	caCollection do:	[		:interface |		
		(interface isInterface)		ifFalse: [ AssertionFailure signal: ('Can not behave like a non-interface!!'). ].	].		instantiatedClass := (ClassBuilder new)						superclass: self						subclass: aSubclassName						instanceVariableNames: instVarNames						classVariableNames: classVarNames						poolDictionaries: poolDictionaries						category: aCategoryName.		instantiatedClass instVarNamed: 'isInterface' put: isInterface.	instantiatedClass instVarNamed: 'behavesLike' put: caCollection.	^instantiatedClass.! !!MyObject class methodsFor: 'compiling' stamp: 'MM 3/10/2024 03:06'!compile: code		(isInterface and: [ (self methodHasBody: code) ])	ifTrue:	[		AssertionFailure signal: ('Interfaces are not allowed to have methods that define behavior!!' ).	].	super compile: code.! !!MyObject class methodsFor: 'compiling' stamp: 'MM 3/10/2024 02:36'!compile: aSourceCode where: anOrderedCollection	| methodSelector methodArguments insertionIndex addedCode newSourceCode |		methodSelector := (Parser new parseSelector: aSourceCode).	methodArguments := (Parser new parseParameterNames: aSourceCode).		((methodArguments size) = (anOrderedCollection size))	ifFalse:	[		AssertionFailure signal: ('Can not compile method, number of arguments is not equal to the number of constraints!!' ).	].	(isInterface and: [ (self methodHasBody: aSourceCode) ])	ifTrue:	[		AssertionFailure signal: ('Interfaces are not allowed to have methods that define behavior!!' ).	].	addedCode := '	(thisContext arguments) doWithIndex:	[		:argument :index |		| myInstanceType constrainedClassType |				myInstanceType := argument.		constrainedClassType := (Smalltalk at: (', anOrderedCollection, ' at: index) ifAbsent: [ nil ]).		((myInstanceType isKindOf: constrainedClassType) or: [ constrainedClassType isNil ])		ifFalse:		[			AssertionFailure signal: (''Type mismatch!!!! Argument '', index, '' should be '',  constrainedClassType).		].	].'.	"Find the last occurrence of '|' character in the original source code"	insertionIndex := aSourceCode lastIndexOf: $|.	"Check if '|' character is found, indicating we have temporary variables"	(insertionIndex = 0)	ifTrue:	[    		"Split the original method body into lines"		| lines firstLine restOfLines |		lines := aSourceCode lines.		"Extract the first line and the rest of the lines"		firstLine := lines first.		restOfLines := lines allButFirst.		"Inject the added code for type checks after the first line"		restOfLines := restOfLines copyWithFirst: addedCode.		"Construct the new modified source code by concatenating the lines back together"		newSourceCode := firstLine, String lf, restOfLines join.	]	ifFalse:	[    		"Extract the substring before and after the last occurrence of |"    		addedCode := String lf, addedCode.    		"Construct the new modified source code by injecting the new type checks after the last |"    		newSourceCode := aSourceCode copyReplaceFrom: insertionIndex + 1 to: insertionIndex with: addedCode.	].	self compile: newSourceCode notifying: nil.! !